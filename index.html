<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SYMFORM Assessment</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0D1B2A;
            --frame-color: #1B263B;
            --border-color: #415A77;
            --text-color: #E0FBFC;
            --highlight-color: #FFD166;
            --action-color: #E76F51;
            --shadow-color: #0d121b;
            --success-color: #06D6A0;
            --warning-color: #F18F01;
        }

        * { box-sizing: border-box; }
        html, body {
            height: 100%; width: 100%; margin: 0; overflow: hidden;
            background-color: var(--bg-color); font-family: 'Press Start 2P', cursive;
            color: var(--text-color); image-rendering: pixelated;
        }

        .app-container {
            width: 100vw; height: 100vh; display: flex;
            justify-content: center; align-items: center; position: relative;
        }

        canvas {
            display: block; background-color: var(--frame-color);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        /* === UI OVERLAYS === */
        .overlay {
            position: absolute; width: 90%; max-width: 600px;
            background-color: var(--frame-color); border: 4px solid var(--text-color);
            box-shadow: 8px 8px 0px var(--shadow-color); display: flex;
            flex-direction: column; align-items: center; text-align: center;
            padding: 2rem; z-index: 20; max-height: 90vh; overflow-y: auto;
        }

        .overlay h1 { font-size: 2.5em; margin-bottom: 1rem; text-shadow: 3px 3px 0px var(--highlight-color); }
        .overlay h2 { font-size: 1.5em; margin: 1rem 0; color: var(--highlight-color); }
        .overlay p { font-size: 1em; line-height: 1.5; margin-bottom: 1rem; color: var(--border-color); }

        .button {
            margin: 0.5rem; padding: 1rem 2rem; font-family: 'Press Start 2P', cursive;
            font-size: 1em; color: var(--text-color); background-color: var(--action-color);
            border: 4px solid var(--text-color); box-shadow: 4px 4px 0px var(--shadow-color);
            cursor: pointer; transition: all 0.1s ease-out; text-decoration: none;
            display: inline-block; min-width: 200px;
        }
        .button:hover { background-color: var(--highlight-color); color: var(--shadow-color); }
        .button:active { transform: translate(4px, 4px); box-shadow: none; }
        .button.secondary { background-color: var(--border-color); }

        /* === GAME HUD === */
        .game-hud {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px 20px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, rgba(13, 27, 42, 0.9), transparent);
            z-index: 10; font-size: 14px; pointer-events: none;
        }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 5px; }
        .hud-center { font-size: 18px; color: var(--highlight-color); }

        /* === COUNTDOWN OVERLAY === */
        .countdown-overlay {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(13, 27, 42, 0.95); display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 30;
        }
        .countdown-number {
            font-size: 8em; color: var(--highlight-color);
            text-shadow: 4px 4px 0px var(--action-color);
            animation: pulse 1s ease-in-out;
        }
        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* === DASHBOARD STYLES === */
        .dashboard {
            position: absolute; width: 90%; max-width: 1200px; padding: 2rem;
            background-color: var(--frame-color); border: 4px solid var(--text-color);
            box-shadow: 8px 8px 0px var(--shadow-color); overflow-y: auto;
            max-height: 90vh; z-index: 20;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        .session-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem; margin: 2rem 0;
        }

        .session-tile {
            background-color: var(--bg-color); border: 2px solid var(--border-color);
            padding: 1rem; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 2px 2px 0px var(--shadow-color);
        }
        .session-tile:hover {
            border-color: var(--highlight-color); transform: translateY(-2px);
            box-shadow: 4px 6px 0px var(--shadow-color);
        }

        .tile-header { display: flex; justify-content: space-between; margin-bottom: 0.5rem; }
        .tile-date { color: var(--border-color); font-size: 0.8em; }
        .tile-score { color: var(--highlight-color); font-size: 1.2em; }
        .tile-archetype { color: var(--action-color); font-size: 0.9em; margin-top: 0.5rem; }

        .chart-container {
            background-color: var(--bg-color); border: 2px solid var(--border-color);
            padding: 1rem; margin: 1rem 0; min-height: 300px;
        }

        /* === REPORT STYLES === */
        .report-section {
            background-color: var(--bg-color); border: 2px solid var(--border-color);
            padding: 1.5rem; margin: 1rem 0; text-align: left;
        }
        .report-section h3 {
            color: var(--highlight-color); margin-bottom: 1rem; font-size: 1.2em;
        }
        .metric-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem; margin: 1rem 0;
        }
        .metric-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.8rem; background-color: var(--frame-color); 
            border: 1px solid var(--border-color); min-height: 50px;
        }
        .metric-label {
            flex: 1; font-size: 0.9em;
        }
        .metric-value { 
            color: var(--highlight-color); font-weight: bold; 
            text-align: right; flex: 0 0 auto; margin-left: 1rem;
        }

        .archetype-card {
            background: linear-gradient(135deg, var(--action-color), var(--highlight-color));
            color: var(--shadow-color); padding: 2rem; border-radius: 8px;
            text-align: center; margin: 2rem 0; font-weight: bold;
        }

        .archetype-details {
            background-color: var(--bg-color); border: 2px solid var(--border-color);
            padding: 2rem; margin: 1rem 0; text-align: left;
        }

        .archetype-details h4 {
            color: var(--highlight-color); margin-bottom: 1rem;
            font-size: 1.1em;
        }

        .archetype-details p {
            line-height: 1.6; margin-bottom: 1.5rem;
            color: var(--text-color); font-size: 0.9em;
        }

        .traits-list {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.5rem; margin: 1rem 0;
        }

        .trait-item {
            background-color: var(--frame-color); border: 1px solid var(--border-color);
            padding: 0.5rem; font-size: 0.8em; color: var(--border-color);
        }

        .work-style {
            background-color: var(--frame-color); border-left: 4px solid var(--highlight-color);
            padding: 1rem; margin: 1rem 0; font-style: italic;
            color: var(--text-color); font-size: 0.9em; line-height: 1.5;
        }

        .hidden { display: none !important; }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            .overlay { width: 95%; padding: 1rem; }
            .overlay h1 { font-size: 1.8em; }
            .button { font-size: 0.9em; min-width: 150px; padding: 0.8rem 1.5rem; }
            .countdown-number { font-size: 5em; }
            .dashboard { padding: 1rem; }
            .session-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>
        
        <!-- Game HUD -->
        <div id="gameHUD" class="game-hud hidden">
            <div class="hud-left">
                <div id="hudScore">SCORE: 000000</div>
                <div id="hudChain">CHAIN: x1</div>
            </div>
            <div class="hud-center">
                <div id="hudRound">ROUND 1/4</div>
                <div id="hudTimer">60s</div>
            </div>
            <div class="hud-right">
                <div id="hudNodes">NODES: 0</div>
            </div>
        </div>

        <!-- Countdown Overlay -->
        <div id="countdownOverlay" class="countdown-overlay hidden">
            <p style="font-size: 1.5em; margin-bottom: 2rem;">Next Round Starts In</p>
            <div id="countdownNumber" class="countdown-number">5</div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen" class="overlay">
            <h1>SYMFORM</h1>
            <h2>Personality Challenge</h2>
            <p>Play 4 rounds of 60 seconds each. Your gameplay style will reveal insights about your personality and working preferences.</p>
            <p>Control the light form. Absorb matching nodes. Avoid everything else.</p>
            <button class="button" onclick="startAssessment()">Start Challenge</button>
            <button class="button secondary" onclick="showDashboard()">View Dashboard</button>
        </div>

        <!-- Assessment Complete -->
        <div id="assessmentComplete" class="overlay hidden">
            <h1>Challenge Complete</h1>
            <p>Analyzing your gameplay style...</p>
            <div id="generationProgress" style="margin: 2rem 0;">
                <div style="color: var(--highlight-color);">Analyzing Performance Patterns...</div>
            </div>
        </div>

        <!-- Report Screen -->
        <div id="reportScreen" class="overlay hidden">
            <h1>Your Personality Profile</h1>
            <div id="reportContent"></div>
            <div style="margin-top: 2rem;">
                <button class="button" onclick="showDashboard()">View Dashboard</button>
                <button class="button secondary" onclick="showStartScreen()">Play Again</button>
            </div>
        </div>

        <!-- Dashboard -->
        <div id="dashboardScreen" class="dashboard hidden">
            <h1 style="text-align: center; margin-bottom: 2rem;">Game Dashboard</h1>
            
            <div style="text-align: center; margin-bottom: 2rem;">
                <button class="button secondary" onclick="showStartScreen()">New Challenge</button>
                <button class="button secondary" onclick="clearAllData()" style="background-color: var(--warning-color);">Clear Data</button>
            </div>

            <div id="dashboardContent">
                <div class="chart-container">
                    <h3>Performance Over Time</h3>
                    <canvas id="progressChart" width="400" height="200"></canvas>
                </div>

                <h3>Game History</h3>
                <div id="sessionGrid" class="session-grid"></div>
            </div>
        </div>

        <!-- Session Detail -->
        <div id="sessionDetail" class="overlay hidden">
            <h2>Game Session Details</h2>
            <div id="sessionDetailContent"></div>
            <div style="margin-top: 2rem;">
                <button class="button secondary" onclick="showDashboard()">Back to Dashboard</button>
            </div>
        </div>
    </div>

    <script>
        // === GAME CORE ===
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const appContainer = document.querySelector('.app-container');

        // Platform detection
        const isMobile = () => ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Game configuration
        const MOBILE_CONFIG = {
            FORM_RADIUS: 12, NODE_RADIUS: 6, NODE_SPAWN_INTERVAL_MS: 1500,
            MIN_NODE_SPAWN_INTERVAL_MS: 300, SCORE_FOR_BARRIERS: 50, BARRIER_LINE_WIDTH: 2,
            SCORE_PER_NODE: 10, CHAIN_RESET_THRESHOLD_MS: 3000,
            BARRIER_MIN_LENGTH: 60, BARRIER_MAX_LENGTH_FACTOR: 0.4,
        };
        const DESKTOP_CONFIG = {
            FORM_RADIUS: 15, NODE_RADIUS: 8, NODE_SPAWN_INTERVAL_MS: 1500,
            MIN_NODE_SPAWN_INTERVAL_MS: 300, SCORE_FOR_BARRIERS: 50, BARRIER_LINE_WIDTH: 4,
            SCORE_PER_NODE: 10, CHAIN_RESET_THRESHOLD_MS: 3000,
            BARRIER_MIN_LENGTH: 100, BARRIER_MAX_LENGTH_FACTOR: 0.7,
        };

        let GAME_CONFIG = isMobile() ? MOBILE_CONFIG : DESKTOP_CONFIG;

        // === ASSESSMENT STATE ===
        let assessmentState = {
            currentRound: 0,
            maxRounds: 4,
            roundDuration: 60000, // 60 seconds
            isAssessmentActive: false,
            currentSessionData: null,
            roundData: []
        };

        // === GAME STATE ===
        let gameState = {
            isPlaying: false,
            score: 0,
            chainMultiplier: 1,
            nodesAbsorbed: 0,
            startTime: 0,
            roundStartTime: 0,
            lastNodeSpawnTime: 0,
            lastChainTime: 0,
            failureType: null,
            failureLocation: { x: 0, y: 0 }
        };

        // Game objects
        const lightform = { x: 0, y: 0, radius: GAME_CONFIG.FORM_RADIUS, color: '#E0FBFC' };
        const darkform = { x: 0, y: 0, radius: GAME_CONFIG.FORM_RADIUS, color: '#EE4266' };
        const nodes = [];
        const barriers = [];

        // Risk tracking
        let riskMetrics = {
            chainAttempts: [],
            barrierProximityEvents: 0,
            aggressiveMoves: 0,
            totalMoves: 0
        };

        // UI elements
        const gameHUD = document.getElementById('gameHUD');
        const countdownOverlay = document.getElementById('countdownOverlay');
        const countdownNumber = document.getElementById('countdownNumber');

        // === INITIALIZATION ===
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            if (isMobile()) {
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            } else {
                canvas.addEventListener('mousemove', handleMouseMove);
            }

            // Initialize with start screen
            showStartScreen();
        }

        // === CANVAS & RENDERING ===
        function resizeCanvas() {
            if (isMobile()) {
                const screenWidth = appContainer.clientWidth;
                const screenHeight = appContainer.clientHeight;
                const targetAspectRatio = 9 / 16;
                let newWidth, newHeight;
                
                if (screenWidth / screenHeight > targetAspectRatio) {
                    newHeight = screenHeight;
                    newWidth = newHeight * targetAspectRatio;
                } else {
                    newWidth = screenWidth;
                    newHeight = newWidth / targetAspectRatio;
                }
                
                canvas.width = Math.round(newWidth);
                canvas.height = Math.round(newHeight);
            } else {
                canvas.width = appContainer.clientWidth;
                canvas.height = appContainer.clientHeight;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw barriers
            ctx.strokeStyle = '#778DA9';
            ctx.lineWidth = GAME_CONFIG.BARRIER_LINE_WIDTH;
            for (const barrier of barriers) {
                ctx.beginPath();
                ctx.moveTo(barrier.x1, barrier.y1);
                ctx.lineTo(barrier.x2, barrier.y2);
                ctx.stroke();
            }
            
            // Draw nodes
            for (const node of nodes) {
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
                ctx.fillStyle = node.fillColor;
                ctx.fill();
                ctx.strokeStyle = node.strokeColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw forms
            drawForm(lightform);
            drawForm(darkform);
        }

        function drawForm(form) {
            // Aura
            ctx.beginPath();
            ctx.arc(form.x, form.y, form.radius + 4, 0, 2 * Math.PI);
            ctx.fillStyle = form.color + '40';
            ctx.fill();
            
            // Form
            ctx.beginPath();
            ctx.arc(form.x, form.y, form.radius, 0, 2 * Math.PI);
            ctx.fillStyle = form.color;
            ctx.fill();
        }

        // === CONTROLS ===
        function handleMouseMove(event) {
            if (!gameState.isPlaying) return;
            
            const rect = canvas.getBoundingClientRect();
            lightform.x = Math.max(GAME_CONFIG.FORM_RADIUS, 
                Math.min(canvas.width - GAME_CONFIG.FORM_RADIUS, event.clientX - rect.left));
            lightform.y = Math.max(GAME_CONFIG.FORM_RADIUS, 
                Math.min(canvas.height - GAME_CONFIG.FORM_RADIUS, event.clientY - rect.top));
            updateDarkformPosition();
            trackRiskMetrics();
        }

        let touchStartX, touchStartY, formStartX, formStartY;

        function handleTouchStart(event) {
            event.preventDefault();
            if (!gameState.isPlaying) return;
            
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            formStartX = lightform.x;
            formStartY = lightform.y;
        }

        function handleTouchMove(event) {
            event.preventDefault();
            if (!gameState.isPlaying) return;
            
            const touch = event.touches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            
            lightform.x = Math.max(GAME_CONFIG.FORM_RADIUS,
                Math.min(canvas.width - GAME_CONFIG.FORM_RADIUS, formStartX + deltaX));
            lightform.y = Math.max(GAME_CONFIG.FORM_RADIUS,
                Math.min(canvas.height - GAME_CONFIG.FORM_RADIUS, formStartY + deltaY));
            updateDarkformPosition();
            trackRiskMetrics();
        }

        function updateDarkformPosition() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            darkform.x = Math.max(GAME_CONFIG.FORM_RADIUS,
                Math.min(canvas.width - GAME_CONFIG.FORM_RADIUS, centerX + (centerX - lightform.x)));
            darkform.y = Math.max(GAME_CONFIG.FORM_RADIUS,
                Math.min(canvas.height - GAME_CONFIG.FORM_RADIUS, centerY + (centerY - lightform.y)));
        }

        // === RISK METRICS TRACKING ===
        function trackRiskMetrics() {
            riskMetrics.totalMoves++;
            
            // Check proximity to barriers
            for (const barrier of barriers) {
                const dist = distanceToLineSegment(lightform.x, lightform.y, barrier.x1, barrier.y1, barrier.x2, barrier.y2);
                if (dist < GAME_CONFIG.FORM_RADIUS + 20) {
                    riskMetrics.barrierProximityEvents++;
                }
            }
        }

        // === GAME LOGIC ===
        function spawnNode() {
            const type = Math.random() < 0.5 ? 'light' : 'dark';
            let x, y;
            
            do {
                x = Math.random() * (canvas.width - 2 * GAME_CONFIG.NODE_RADIUS) + GAME_CONFIG.NODE_RADIUS;
                y = Math.random() * (canvas.height - 2 * GAME_CONFIG.NODE_RADIUS) + GAME_CONFIG.NODE_RADIUS;
            } while (isPositionInsideBarrier(x, y, GAME_CONFIG.NODE_RADIUS));
            
            nodes.push({
                x, y,
                radius: GAME_CONFIG.NODE_RADIUS,
                type,
                fillColor: type === 'light' ? lightform.color : darkform.color,
                strokeColor: type === 'light' ? '#0D1B2A' : lightform.color
            });
        }

        function spawnBarriers(count) {
            for (let i = 0; i < count; i++) {
                let x1, y1, x2, y2;
                const minLength = GAME_CONFIG.BARRIER_MIN_LENGTH;
                const maxLength = Math.min(canvas.width, canvas.height) * GAME_CONFIG.BARRIER_MAX_LENGTH_FACTOR;
                const padding = GAME_CONFIG.FORM_RADIUS * 2 + 20;
                
                if (Math.random() < 0.5) {
                    // Horizontal barrier
                    y1 = y2 = Math.random() * (canvas.height - 2 * padding) + padding;
                    x1 = Math.random() * (canvas.width - minLength - 2 * padding) + padding;
                    x2 = x1 + Math.random() * (maxLength - minLength) + minLength;
                } else {
                    // Vertical barrier
                    x1 = x2 = Math.random() * (canvas.width - 2 * padding) + padding;
                    y1 = Math.random() * (canvas.height - minLength - 2 * padding) + padding;
                    y2 = y1 + Math.random() * (maxLength - minLength) + minLength;
                }
                
                barriers.push({ x1, y1, x2, y2 });
            }
        }

        function checkCollisions() {
            // Check node collisions
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                
                if (node.type === 'light') {
                    if (checkCircleCollision(lightform, node)) {
                        absorbNode(node);
                        nodes.splice(i, 1);
                        continue;
                    }
                    if (checkCircleCollision(darkform, node)) {
                        return endRound('node', darkform.x, darkform.y);
                    }
                } else {
                    if (checkCircleCollision(darkform, node)) {
                        absorbNode(node);
                        nodes.splice(i, 1);
                        continue;
                    }
                    if (checkCircleCollision(lightform, node)) {
                        return endRound('node', lightform.x, lightform.y);
                    }
                }
            }
            
            // Check barrier collisions
            for (const barrier of barriers) {
                if (checkLineCircleCollision(barrier, lightform)) {
                    return endRound('barrier', lightform.x, lightform.y);
                }
                if (checkLineCircleCollision(barrier, darkform)) {
                    return endRound('barrier', darkform.x, darkform.y);
                }
            }
            
            return false;
        }

        function absorbNode(node) {
            gameState.nodesAbsorbed++;
            gameState.chainMultiplier++;
            gameState.score += GAME_CONFIG.SCORE_PER_NODE * gameState.chainMultiplier;
            gameState.lastChainTime = performance.now();
            
            riskMetrics.chainAttempts.push(gameState.chainMultiplier);
            
            updateHUD();
        }

        function endRound(failureType, x, y) {
            gameState.failureType = failureType;
            gameState.failureLocation = { x, y };
            return true;
        }

        // === COLLISION DETECTION ===
        function checkCircleCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (circle1.radius + circle2.radius);
        }

        function checkLineCircleCollision(line, circle) {
            const dist = distanceToLineSegment(circle.x, circle.y, line.x1, line.y1, line.x2, line.y2);
            return dist < circle.radius + 2;
        }

        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function isPositionInsideBarrier(x, y, radius) {
            for (const barrier of barriers) {
                if (distanceToLineSegment(x, y, barrier.x1, barrier.y1, barrier.x2, barrier.y2) < radius + 5) {
                    return true;
                }
            }
            return false;
        }

        // === HUD UPDATES ===
        function updateHUD() {
            document.getElementById('hudScore').textContent = `SCORE: ${String(gameState.score).padStart(6, '0')}`;
            document.getElementById('hudChain').textContent = `CHAIN: x${gameState.chainMultiplier}`;
            document.getElementById('hudRound').textContent = `ROUND ${assessmentState.currentRound}/4`;
            document.getElementById('hudNodes').textContent = `NODES: ${gameState.nodesAbsorbed}`;
            
            const timeLeft = Math.max(0, Math.ceil((assessmentState.roundDuration - (performance.now() - gameState.roundStartTime)) / 1000));
            document.getElementById('hudTimer').textContent = `${timeLeft}s`;
        }

        // === ASSESSMENT FLOW ===
        function startAssessment() {
            assessmentState.isAssessmentActive = true;
            assessmentState.currentRound = 0;
            assessmentState.roundData = [];
            assessmentState.currentSessionData = {
                id: Date.now(),
                date: new Date().toLocaleDateString(),
                rounds: []
            };
            
            hideAllScreens();
            startNextRound();
        }

        function startNextRound() {
            assessmentState.currentRound++;
            
            if (assessmentState.currentRound > assessmentState.maxRounds) {
                completeAssessment();
                return;
            }
            
            // Show countdown if not first round
            if (assessmentState.currentRound > 1) {
                showCountdown(() => startGameRound());
            } else {
                startGameRound();
            }
        }

        function showCountdown(callback) {
            countdownOverlay.classList.remove('hidden');
            let count = 5;
            
            function updateCountdown() {
                countdownNumber.textContent = count;
                countdownNumber.style.animation = 'none';
                setTimeout(() => {
                    countdownNumber.style.animation = 'pulse 1s ease-in-out';
                }, 10);
                
                if (count <= 0) {
                    countdownOverlay.classList.add('hidden');
                    callback();
                } else {
                    count--;
                    setTimeout(updateCountdown, 1000);
                }
            }
            
            updateCountdown();
        }

        function startGameRound() {
            // Reset game state
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.chainMultiplier = 1;
            gameState.nodesAbsorbed = 0;
            gameState.roundStartTime = performance.now();
            gameState.lastNodeSpawnTime = performance.now();
            gameState.lastChainTime = performance.now();
            gameState.failureType = null;
            
            // Reset risk metrics
            riskMetrics = {
                chainAttempts: [],
                barrierProximityEvents: 0,
                aggressiveMoves: 0,
                totalMoves: 0
            };
            
            // Reset game objects
            nodes.length = 0;
            barriers.length = 0;
            
            // Position forms
            lightform.x = canvas.width / 2;
            lightform.y = canvas.height / 2;
            updateDarkformPosition();
            
            // Spawn initial barriers if needed
            if (gameState.score >= GAME_CONFIG.SCORE_FOR_BARRIERS) {
                spawnBarriers(1);
            }
            
            gameHUD.classList.remove('hidden');
            updateHUD();
            
            gameLoop();
        }

        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            const currentTime = performance.now();
            const elapsed = currentTime - gameState.roundStartTime;
            
            // Check if round time is up
            if (elapsed >= assessmentState.roundDuration) {
                finishRound('timeout');
                return;
            }
            
            // Spawn nodes
            if (currentTime - gameState.lastNodeSpawnTime > GAME_CONFIG.NODE_SPAWN_INTERVAL_MS) {
                spawnNode();
                gameState.lastNodeSpawnTime = currentTime;
            }
            
            // Reset chain if too much time passed
            if (currentTime - gameState.lastChainTime > GAME_CONFIG.CHAIN_RESET_THRESHOLD_MS && gameState.chainMultiplier > 1) {
                gameState.chainMultiplier = 1;
            }
            
            // Spawn barriers based on score
            if (gameState.score >= GAME_CONFIG.SCORE_FOR_BARRIERS && barriers.length === 0) {
                spawnBarriers(1);
            } else if (gameState.score >= GAME_CONFIG.SCORE_FOR_BARRIERS + (barriers.length * 30) && barriers.length < 3) {
                spawnBarriers(1);
            }
            
            // Check collisions
            if (checkCollisions()) {
                finishRound(gameState.failureType);
                return;
            }
            
            updateHUD();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function finishRound(endReason) {
            gameState.isPlaying = false;
            
            const roundData = {
                roundNumber: assessmentState.currentRound,
                finalScore: gameState.score,
                nodesAbsorbed: gameState.nodesAbsorbed,
                highestChain: Math.max(...riskMetrics.chainAttempts, 1),
                timeSurvived: Math.min(60, Math.floor((performance.now() - gameState.roundStartTime) / 1000)),
                failureType: endReason,
                failureLocation: gameState.failureLocation,
                riskMetrics: {
                    avgChainLength: riskMetrics.chainAttempts.length > 0 ? 
                        riskMetrics.chainAttempts.reduce((a, b) => a + b, 0) / riskMetrics.chainAttempts.length : 1,
                    maxChainAttempt: Math.max(...riskMetrics.chainAttempts, 1),
                    barrierProximityScore: riskMetrics.barrierProximityEvents,
                    aggressionIndex: riskMetrics.totalMoves > 0 ? riskMetrics.aggressiveMoves / riskMetrics.totalMoves : 0
                }
            };
            
            assessmentState.roundData.push(roundData);
            assessmentState.currentSessionData.rounds.push(roundData);
            
            gameHUD.classList.add('hidden');
            
            setTimeout(() => {
                startNextRound();
            }, 1000);
        }

        function completeAssessment() {
            gameHUD.classList.add('hidden');
            
            // Generate psychological profile
            const profile = generatePsychologicalProfile(assessmentState.currentSessionData);
            assessmentState.currentSessionData.psychProfile = profile;
            
            // Save to localStorage
            saveSessionData(assessmentState.currentSessionData);
            
            // Show generation screen
            showAssessmentComplete();
            
            // Show report after delay
            setTimeout(() => {
                showReport(assessmentState.currentSessionData);
            }, 3000);
        }

        // === PSYCHOLOGICAL ANALYSIS ===
        function generatePsychologicalProfile(sessionData) {
            const rounds = sessionData.rounds;
            
            // 1. Performance Trajectory
            const scores = rounds.map(r => r.finalScore);
            const performanceTrajectory = analyzePerformanceTrajectory(scores);
            
            // 2. Strategic Evolution
            const strategicEvolution = analyzeStrategicEvolution(rounds);
            
            // 3. Error Pattern Migration
            const errorPatternMigration = analyzeErrorPatterns(rounds);
            
            // 4. Risk Assessment
            const riskCategory = assessRiskCategory(rounds);
            
            // 5. Adaptation Level
            const adaptationLevel = assessAdaptationLevel(performanceTrajectory, strategicEvolution, errorPatternMigration);
            
            // 6. Determine Archetype
            const archetype = determineArchetype(riskCategory, adaptationLevel);
            
            return {
                performanceTrajectory,
                strategicEvolution,
                errorPatternMigration,
                riskCategory,
                adaptationLevel,
                archetype,
                analysis: generateDetailedAnalysis(rounds, performanceTrajectory, strategicEvolution, errorPatternMigration, riskCategory, adaptationLevel)
            };
        }

        function analyzePerformanceTrajectory(scores) {
            if (scores.length < 2) return 'insufficient_data';
            
            const firstHalf = scores.slice(0, 2).reduce((a, b) => a + b, 0) / 2;
            const secondHalf = scores.slice(2).reduce((a, b) => a + b, 0) / 2;
            
            const improvement = secondHalf - firstHalf;
            const improvementPercent = firstHalf > 0 ? (improvement / firstHalf) * 100 : 0;
            
            if (improvementPercent > 20) return 'positive';
            if (improvementPercent < -10) return 'negative';
            return 'stagnant';
        }

        function analyzeStrategicEvolution(rounds) {
            const chainToSurvivalRatios = rounds.map(r => r.highestChain / (r.timeSurvived + 1));
            
            if (chainToSurvivalRatios.length < 2) return 'insufficient_data';
            
            const early = chainToSurvivalRatios.slice(0, 2).reduce((a, b) => a + b, 0) / 2;
            const late = chainToSurvivalRatios.slice(2).reduce((a, b) => a + b, 0) / 2;
            
            const survivalToChain = rounds.map(r => r.timeSurvived / (r.highestChain + 1));
            const earlySurvival = survivalToChain.slice(0, 2).reduce((a, b) => a + b, 0) / 2;
            const lateSurvival = survivalToChain.slice(2).reduce((a, b) => a + b, 0) / 2;
            
            if (late > early * 1.2) return 'survival-to-dominance';
            if (lateSurvival > earlySurvival * 1.2) return 'reckless-to-control';
            return 'static';
        }

        function analyzeErrorPatterns(rounds) {
            const errorTypes = rounds.map(r => r.failureType);
            const early = errorTypes.slice(0, 2);
            const late = errorTypes.slice(2);
            
            const earlyBarriers = early.filter(t => t === 'barrier').length;
            const lateNodes = late.filter(t => t === 'node').length;
            
            if (earlyBarriers >= 1 && lateNodes >= 1) return 'strategic-to-execution';
            
            const allSameType = errorTypes.every(t => t === errorTypes[0]);
            if (allSameType) return 'fixed-pattern';
            
            return 'random';
        }

        function assessRiskCategory(rounds) {
            const avgChainLength = rounds.reduce((sum, r) => sum + r.riskMetrics.avgChainLength, 0) / rounds.length;
            const avgProximity = rounds.reduce((sum, r) => sum + r.riskMetrics.barrierProximityScore, 0) / rounds.length;
            
            const riskScore = avgChainLength * 0.6 + avgProximity * 0.4;
            
            if (riskScore > 3) return 'high';
            if (riskScore < 1.5) return 'low';
            return 'balanced';
        }

        function assessAdaptationLevel(performanceTrajectory, strategicEvolution, errorPatternMigration) {
            let adaptationScore = 0;
            
            if (performanceTrajectory === 'positive') adaptationScore += 2;
            else if (performanceTrajectory === 'negative') adaptationScore -= 1;
            
            if (strategicEvolution !== 'static') adaptationScore += 2;
            
            if (errorPatternMigration === 'strategic-to-execution') adaptationScore += 2;
            else if (errorPatternMigration === 'fixed-pattern') adaptationScore -= 1;
            
            if (adaptationScore >= 4) return 'plastic';
            if (adaptationScore <= 1) return 'rigid';
            return 'developing';
        }

        function determineArchetype(riskCategory, adaptationLevel) {
            const archetypes = {
                'high-rigid': {
                    name: 'The Reckless Maverick',
                    description: 'Starts aggressive, stays aggressive. Fails to learn from repeated, high-risk errors. Confuses motion with progress and sees failure as bad luck, not bad strategy.',
                    traits: ['High ambition', 'Poor feedback integration', 'Impulsive decision-making', 'Overconfident'],
                    workStyle: 'Needs strict oversight and structured feedback. May excel in high-energy, crisis situations but struggles with systematic improvement.'
                },
                'high-developing': {
                    name: 'The Driven Specialist',
                    description: 'Possesses immense drive but lacks refinement. Shows flashes of brilliance between frustrating setbacks. Is on an upward, albeit volatile, trajectory.',
                    traits: ['High motivation', 'Moderate adaptability', 'Performance volatility', 'Growth potential'],
                    workStyle: 'Needs mentorship and coaching. Best in roles where passion and drive are valued, with support systems for skill development.'
                },
                'high-plastic': {
                    name: 'The Apex Strategist',
                    description: 'The ideal high-growth profile. Combines ambition with intelligence. Starts strong and rapidly incorporates feedback to get stronger, quickly mastering complexities.',
                    traits: ['High intelligence', 'Excellent adaptability', 'Strategic thinking', 'Leadership potential'],
                    workStyle: 'Natural leader and problem-solver. Thrives in challenging, dynamic environments. Ideal for strategic roles and rapid advancement.'
                },
                'balanced-rigid': {
                    name: 'The Complacent Bureaucrat',
                    description: 'Plays by the book and follows a single, safe strategy without deviation. Performance is consistent but stagnant. Resists coaching and new methods.',
                    traits: ['Risk-averse', 'Consistent performance', 'Resistant to change', 'Process-oriented'],
                    workStyle: 'Best in stable, structured environments with clear procedures. May struggle with innovation or rapid change initiatives.'
                },
                'balanced-developing': {
                    name: 'The Reliable Professional',
                    description: 'The core of any team. Steady, dependable, and open to feedback. Shows gradual, consistent improvement over time. Can be counted on to learn new processes.',
                    traits: ['Reliable', 'Coachable', 'Steady improvement', 'Team-oriented'],
                    workStyle: 'Backbone of most organizations. Excellent for operational roles, project management, and team coordination. Responds well to training programs.'
                },
                'balanced-plastic': {
                    name: 'The Rising Star',
                    description: 'A highly coachable, pragmatic individual. Quickly masters new skills and integrates feedback to become highly effective. Displays high potential for leadership.',
                    traits: ['High adaptability', 'Balanced risk-taking', 'Strong learning ability', 'Leadership material'],
                    workStyle: 'Ideal for career advancement and leadership development. Excels in roles requiring both stability and innovation.'
                },
                'low-rigid': {
                    name: 'The Obstinate Anchor',
                    description: 'Their defensive posture is rigid dogma, not strategy. They fail to adapt even when their cautious approach yields poor results. A liability in dynamic environments.',
                    traits: ['Extremely risk-averse', 'Inflexible', 'Resistant to feedback', 'Change-adverse'],
                    workStyle: 'May struggle in modern dynamic workplaces. Best suited for highly routine, low-change environments with minimal decision-making requirements.'
                },
                'low-developing': {
                    name: 'The Cautious Apprentice',
                    description: 'Starts with a strong defensive shell but is slowly learning to take calculated risks. Building confidence with each session. Responds well to encouragement.',
                    traits: ['Cautious', 'Growing confidence', 'Responsive to coaching', 'Detail-oriented'],
                    workStyle: 'Needs supportive environment and gradual responsibility increases. Excellent for roles requiring attention to detail and careful analysis.'
                },
                'low-plastic': {
                    name: 'The Master Tactician',
                    description: 'Chooses a defensive style and perfects it. Learns the system\'s rules to profound depth, optimizing for flawless execution and survival. Master of control and precision.',
                    traits: ['Strategic patience', 'Precision-focused', 'Risk-aware', 'Methodical'],
                    workStyle: 'Excellent for roles requiring precision, planning, and risk management. Natural fit for compliance, quality control, and strategic planning roles.'
                }
            };
            
            return archetypes[`${riskCategory}-${adaptationLevel}`] || {
                name: 'Unknown Archetype',
                description: 'Insufficient data for classification.',
                traits: ['Analysis pending'],
                workStyle: 'Additional assessment required.'
            };
        }

        function generateDetailedAnalysis(rounds, performanceTrajectory, strategicEvolution, errorPatternMigration, riskCategory, adaptationLevel) {
            const totalScore = rounds.reduce((sum, r) => sum + r.finalScore, 0);
            const totalNodes = rounds.reduce((sum, r) => sum + r.nodesAbsorbed, 0);
            const avgSurvival = rounds.reduce((sum, r) => sum + r.timeSurvived, 0) / rounds.length;
            const maxChain = Math.max(...rounds.map(r => r.highestChain));
            
            return {
                totalScore,
                totalNodes,
                avgSurvival: Math.round(avgSurvival * 10) / 10,
                maxChain,
                consistencyScore: calculateConsistency(rounds.map(r => r.finalScore)),
                improvementRate: calculateImprovementRate(rounds.map(r => r.finalScore)),
                riskTolerance: assessRiskTolerance(rounds)
            };
        }

        function calculateConsistency(scores) {
            if (scores.length < 2) return 0;
            const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
            const standardDeviation = Math.sqrt(variance);
            return Math.max(0, 100 - (standardDeviation / mean) * 100);
        }

        function calculateImprovementRate(scores) {
            if (scores.length < 2) return 0;
            const firstScore = scores[0];
            const lastScore = scores[scores.length - 1];
            return firstScore > 0 ? ((lastScore - firstScore) / firstScore) * 100 : 0;
        }

        function assessRiskTolerance(rounds) {
            const riskScores = rounds.map(r => r.riskMetrics.avgChainLength + r.riskMetrics.barrierProximityScore);
            return riskScores.reduce((a, b) => a + b, 0) / riskScores.length;
        }

        // === DATA PERSISTENCE ===
        function saveSessionData(sessionData) {
            try {
                const existingData = JSON.parse(localStorage.getItem('symformSessions') || '[]');
                existingData.push(sessionData);
                localStorage.setItem('symformSessions', JSON.stringify(existingData));
            } catch (error) {
                console.error('Failed to save session data:', error);
            }
        }

        function loadAllSessions() {
            try {
                return JSON.parse(localStorage.getItem('symformSessions') || '[]');
            } catch (error) {
                console.error('Failed to load session data:', error);
                return [];
            }
        }

        function clearAllData() {
            if (confirm('Are you sure you want to delete all game data? This cannot be undone.')) {
                localStorage.removeItem('symformSessions');
                showDashboard();
            }
        }

        // === UI SCREENS ===
        function hideAllScreens() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('assessmentComplete').classList.add('hidden');
            document.getElementById('reportScreen').classList.add('hidden');
            document.getElementById('dashboardScreen').classList.add('hidden');
            document.getElementById('sessionDetail').classList.add('hidden');
            countdownOverlay.classList.add('hidden');
            gameHUD.classList.add('hidden');
        }

        function showStartScreen() {
            hideAllScreens();
            document.getElementById('startScreen').classList.remove('hidden');
            draw();
        }

        function showAssessmentComplete() {
            hideAllScreens();
            document.getElementById('assessmentComplete').classList.remove('hidden');
            
            const messages = [
                'Analyzing Performance Patterns...',
                'Studying Gameplay Style...',
                'Examining Decision Making...',
                'Evaluating Risk Preferences...',
                'Assessing Learning Patterns...',
                'Revealing Your Personality Type...'
            ];
            
            let messageIndex = 0;
            const progressElement = document.getElementById('generationProgress');
            
            function updateProgress() {
                if (messageIndex < messages.length) {
                    progressElement.innerHTML = `<div style="color: var(--highlight-color);">${messages[messageIndex]}</div>`;
                    messageIndex++;
                    setTimeout(updateProgress, 500);
                }
            }
            
            updateProgress();
        }

        function showReport(sessionData) {
            hideAllScreens();
            document.getElementById('reportScreen').classList.remove('hidden');
            
            const reportContent = document.getElementById('reportContent');
            const profile = sessionData.psychProfile;
            const archetype = profile.archetype;
            
            reportContent.innerHTML = `
                <div class="archetype-card">
                    <h2>${archetype.name}</h2>
                    <p style="margin-top: 1rem; font-size: 0.9em; opacity: 0.9;">Your personality type based on gameplay style</p>
                </div>
                
                <div class="archetype-details">
                    <h4>Your Gaming Personality</h4>
                    <p>${archetype.description}</p>
                    
                    <h4>Key Traits</h4>
                    <div class="traits-list">
                        ${archetype.traits.map(trait => `<div class="trait-item">• ${trait}</div>`).join('')}
                    </div>
                    
                    <h4>How You Approach Challenges</h4>
                    <div class="work-style">${archetype.workStyle}</div>
                </div>
                
                <div class="report-section">
                    <h3>Performance Summary</h3>
                    <div class="metric-grid">
                        <div class="metric-item">
                            <span class="metric-label">Total Score</span>
                            <span class="metric-value">${profile.analysis.totalScore}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Performance Trend</span>
                            <span class="metric-value">${capitalizeFirst(profile.performanceTrajectory)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Improvement Rate</span>
                            <span class="metric-value">${Math.round(profile.analysis.improvementRate)}%</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Consistency Score</span>
                            <span class="metric-value">${Math.round(profile.analysis.consistencyScore)}%</span>
                        </div>
                    </div>
                </div>
                
                <div class="report-section">
                    <h3>Playing Style Analysis</h3>
                    <div class="metric-grid">
                        <div class="metric-item">
                            <span class="metric-label">Risk Taking Style</span>
                            <span class="metric-value">${capitalizeFirst(profile.riskCategory)} Risk</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Learning Style</span>
                            <span class="metric-value">${capitalizeFirst(profile.adaptationLevel)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Strategy Evolution</span>
                            <span class="metric-value">${formatStrategyType(profile.strategicEvolution)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Mistake Pattern</span>
                            <span class="metric-value">${formatErrorPattern(profile.errorPatternMigration)}</span>
                        </div>
                    </div>
                </div>
                
                <div class="report-section">
                    <h3>Game Statistics</h3>
                    <div class="metric-grid">
                        <div class="metric-item">
                            <span class="metric-label">Total Nodes Collected</span>
                            <span class="metric-value">${profile.analysis.totalNodes}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Best Chain Combo</span>
                            <span class="metric-value">x${profile.analysis.maxChain}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Average Survival Time</span>
                            <span class="metric-value">${profile.analysis.avgSurvival}s</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Risk Index</span>
                            <span class="metric-value">${Math.round(profile.analysis.riskTolerance * 10) / 10}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        function formatStrategyType(strategy) {
            const formats = {
                'survival-to-dominance': 'Defensive → Aggressive',
                'reckless-to-control': 'Reckless → Controlled',
                'static': 'No Evolution',
                'insufficient_data': 'Insufficient Data'
            };
            return formats[strategy] || strategy;
        }

        function formatErrorPattern(pattern) {
            const formats = {
                'strategic-to-execution': 'Strategic → Execution',
                'fixed-pattern': 'Fixed Pattern',
                'random': 'Random Pattern',
                'insufficient_data': 'Insufficient Data'
            };
            return formats[pattern] || pattern;
        }

        function showDashboard() {
            hideAllScreens();
            document.getElementById('dashboardScreen').classList.remove('hidden');
            
            const sessions = loadAllSessions();
            renderSessionGrid(sessions);
            renderProgressChart(sessions);
        }

        function renderSessionGrid(sessions) {
            const sessionGrid = document.getElementById('sessionGrid');
            
            if (sessions.length === 0) {
                sessionGrid.innerHTML = `
                    <div style="text-align: center; padding: 3rem; color: var(--border-color);">
                        <h3 style="color: var(--highlight-color); margin-bottom: 1rem;">No Games Yet</h3>
                        <p style="margin-bottom: 2rem;">Play your first challenge to see your personality insights and progress tracking here.</p>
                        <button class="button" onclick="showStartScreen()">Play First Game</button>
                    </div>
                `;
                return;
            }
            
            sessionGrid.innerHTML = sessions.map(session => {
                const totalScore = session.rounds ? session.rounds.reduce((sum, r) => sum + r.finalScore, 0) : 0;
                const archetypeName = session.psychProfile && session.psychProfile.archetype ? 
                    (typeof session.psychProfile.archetype === 'string' ? 
                        session.psychProfile.archetype : 
                        session.psychProfile.archetype.name) : 'Analysis Pending';
                return `
                    <div class="session-tile" onclick="showSessionDetail('${session.id}')">
                        <div class="tile-header">
                            <span class="tile-date">${session.date}</span>
                            <span class="tile-score">${totalScore}</span>
                        </div>
                        <div class="tile-archetype">${archetypeName}</div>
                    </div>
                `;
            }).join('');
        }

        function renderProgressChart(sessions) {
            const canvas = document.getElementById('progressChart');
            const ctx = canvas.getContext('2d');
            
            if (sessions.length === 0) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Setup
            const padding = 40;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;
            
            const scores = sessions.map(s => s.rounds.reduce((sum, r) => sum + r.finalScore, 0));
            const maxScore = Math.max(...scores, 100);
            
            // Draw axes
            ctx.strokeStyle = '#415A77';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Draw score line
            if (scores.length > 1) {
                ctx.strokeStyle = '#FFD166';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                scores.forEach((score, index) => {
                    const x = padding + (index / (scores.length - 1)) * chartWidth;
                    const y = canvas.height - padding - (score / maxScore) * chartHeight;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }
            
            // Draw points
            ctx.fillStyle = '#E76F51';
            scores.forEach((score, index) => {
                const x = padding + (index / Math.max(scores.length - 1, 1)) * chartWidth;
                const y = canvas.height - padding - (score / maxScore) * chartHeight;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Labels
            ctx.fillStyle = '#E0FBFC';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('Score Progress Over Time', padding, 20);
        }

        function showSessionDetail(sessionId) {
            const sessions = loadAllSessions();
            const session = sessions.find(s => s.id === parseInt(sessionId));
            
            if (!session) return;
            
            hideAllScreens();
            document.getElementById('sessionDetail').classList.remove('hidden');
            
            const content = document.getElementById('sessionDetailContent');
            const archetypeName = session.psychProfile && session.psychProfile.archetype ? 
                (typeof session.psychProfile.archetype === 'string' ? 
                    session.psychProfile.archetype : 
                    session.psychProfile.archetype.name) : 'Analysis Pending';
            
            content.innerHTML = `
                <h3>Game Session from ${session.date}</h3>
                
                <div class="report-section">
                    <h3>Round-by-Round Performance</h3>
                    ${session.rounds.map(round => `
                        <div class="metric-item" style="margin: 0.5rem 0;">
                            <span class="metric-label">Round ${round.roundNumber}</span>
                            <span class="metric-value">Score: ${round.finalScore} | Chain: ${round.highestChain} | Time: ${round.timeSurvived}s</span>
                        </div>
                    `).join('')}
                </div>
                
                <div class="report-section">
                    <h3>Personality Results</h3>
                    <div class="archetype-card" style="margin: 1rem 0;">
                        <h3>${archetypeName}</h3>
                    </div>
                    <div class="metric-grid">
                        <div class="metric-item">
                            <span class="metric-label">Risk Style</span>
                            <span class="metric-value">${capitalizeFirst(session.psychProfile.riskCategory)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Learning Style</span>
                            <span class="metric-value">${capitalizeFirst(session.psychProfile.adaptationLevel)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Performance Trend</span>
                            <span class="metric-value">${capitalizeFirst(session.psychProfile.performanceTrajectory)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Strategy Evolution</span>
                            <span class="metric-value">${formatStrategyType(session.psychProfile.strategicEvolution)}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // === INITIALIZATION ===
        window.onload = init;
    </script>
</body>
</html>
